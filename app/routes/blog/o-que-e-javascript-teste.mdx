---
title: But really, what is a JavaScript test?
date: 2018-01-01
meta:
    title: Teste Javascript
    description: Entendendo testes em JavaScript from scratch!
---

#### Testar c√≥digo. 

Existem milhares de motivos para testar um c√≥digo. Cito meus dois favoritos:
1. Pensar no resultado que eu quero chegar antes de codar.  
2. Confian√ßa de que o que eu fiz n√£o vai quebrar o software.

Dito isso, eu tenho algumas **perguntas** para voc√™:
- Voc√™ j√° escreveu algum teste em Javascript?
- Voc√™ j√° usou algum framework de teste em Javascript?
- Voc√™ entende bem sobre framework de testes a ponto de criar um pr√≥prio, ainda que bem simples?


O **objetivo** desse post √© que voc√™ consiga responder "sim" para as perguntas que fiz acima, mas eu queria mesmo √© que voc√™
sentisse o que eu senti ao conseguir respond√™-las pela primeira vez quando terminei de ler o [post](https://kentcdodds.com/blog/but-really-what-is-a-javascript-test) do Kent C Dodds sobre esse assunto.

#### Vamos come√ßar! (E eu estou bem animado com isso!)

Primeiro vamos criar um simples modulo `math.js` com duas fun√ß√µes de matem√°tica
e escrever testes para essas fun√ß√µes:

```js
const somar = (a, b) => a + b
const subtrair = (a, b) => a - b

module.exports = {somar, subtrair}
```

Fiz um [repo no GitHub](https://github.com/venancioigor/js-teste-exemplo)
onde voc√™ pode se guiar, caso se perca em algum momento. Sugiro que voc√™ acesse
o repo s√≥ em **√∫ltimo caso**, depois de tentar e pensar em como resolver por no m√≠nimo dois dias. üòÖ


### Passo 1

Qual √© o teste mais b√°sico que voc√™ consegue pensar?
Eis um exemplo com vari√°veis em ingl√™s. No final desse post voc√™ entender√° a raz√£o.

```js
// teste-basico.js
const actual = true
const expected = false
if (actual !== expected) {
  throw new Error(`${actual} √© diferente de ${expected}`)
}
```
Voi l√°! Temos o nosso primeiro teste!

Voc√™ pode rod√°-lo digitando `node teste-basico.js` no console e apertando enter.

**Como podemos ver, um teste √© um c√≥digo que lan√ßa um erro quando o resultado
atual n√£o √© o resultado esperado.**

A parte que faz essa verifica√ß√£o `actual !== expected` √© chamada de **asser√ß√£o**,
que √© basicamente verificar se o nosso resultado √© igual ao resultado esperado.
Se n√£o for, lan√ßa-se uma exce√ß√£o.

Para saber mais sobre asser√ß√£o, l√≥gica proposal [clique aqui.](https://www.infoescola.com/matematica/logica-proposicional/)

Ent√£o, qual √© o teste mais b√°sico que poder√≠amos fazer para as nossas fun√ß√µes do m√≥dulo `math.js`?

```js
// 1.js
const {somar, subtrair} = require('./math')

let result, expected

result = somar(2, 2)
expected = 4

if(result !== expected){
  throw new Error(`${result} √© diferente do resultado esperado: ${expected}`)
}

result = subtrair(4, 2)
expected = 2

if(result !== expected){
  throw new Error(`${result} √© diferente do resultado esperado: ${expected}`)
}

```

Rodando esses testes `node 1.js` voc√™ vai ver que n√£o nenhum erro apareceu no console.
Agora vamos fazer esse teste quebrar? No modulo math.js, vamos alterar o comportamento
da fun√ß√£o somar para ao inv√©s de somar, subtrair.

```js
// math.js
const somar = (a, b) => a - b
```

Pronto!

```js
$ node 1.js
C:\source\github\js-teste-exemplo\1.js:10
    throw new Error(`${actual} √© diferente do resultado esperado ${expected}`)
    ^

Error: 0 √© diferente de 4
    at Object.<anonymous> (C:\source\github\js-teste-exemplo\1.js:10:11)
    at Module._compile (node:internal/modules/cjs/loader:1103:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1155:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```

Deu para perceber que n√£o podemos fazer alguma altera√ß√£o na fun√ß√£o `somar`
sem que quebre os nossos testes autom√°ticos? Estamos protegidos!

**√â essencial que a mensagem de erro seja clara e concisa, onde podemos rapidamente
ver onde est√° o problema e corrigir.**


### Passo 2

Voc√™ sabia que o Node tem
[`um`](https://nodejs.org/api/assert.html#assert_assert)
[module](https://nodejs.org/api/assert.html#assert_assert)
para fazer *asser√ß√µes* como as que fizemos acimaü§î?
Que tal refatorar o nosso teste para utilizar esse m√≥dulo?

```js
// 2.js
const assert = require('assert')
const {somar, subtrair} = require('./math')

let result, expected

result = somar(4, 2)
expect = 6

assert.strictEqual(result, expected)

result = subtrair(4, 2)
expect = 2

assert.strictEqual(result, expected)
```

Certo, agora execute o `node 2.js`no terminal.
Repara que continua sendo um c√≥digo de teste, a √∫nica diferen√ßa est√° na mensagem de erro.

```js
node:assert:123
  throw new AssertionError(obj);
  ^

AssertionError [ERR_ASSERTION]: Expected values to be strictly equal:
    at Object.<anonymous> (C:\source\github\js-teste-exemplo\2.js:9:8)
    at Module._compile (node:internal/modules/cjs/loader:1103:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1155:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47 {
  generatedMessage: true,
  code: 'ERR_ASSERTION',
  actual: -4,
  expected: 10,
  operator: 'strictEqual'
}
```

No teste que a gente criou, a mensagem de erro diz a linha onde que foi lan√ßado o erro,
mas utilizando o modulo que j√° vem com o node, a mensagem de erro s√≥ nos diz que o resultado
√© diferente do esperado. 

Ent√£o, como saber se o teste falhou na fun√ß√£o somar ou na de subtrair? **n√£o tem como!** üò¶

### Passo 3

Que tal criar a nossa pr√≥pria lib para fazer asser√ß√µes? Assim que gente passa a estar no controle!
Ao inv√©s de chamar o m√≥dulo `assert` vamos criar uma fun√ß√£o chamada `expect`.  üòé

Vamos criar um novo arquivo chamado 3.js:

```js
// 3.js
const {somar, subtrair} = require('./math')

let result, expected

result = somar(4, 2)
expected = 6

expect(result).toBe(expected)

result = subtrair(4, 2)
expected = 2


// Criando a nossa fun√ß√£o expect, aplicando os conceitos aprendidos anteriormente.
function expect(result){
  return {
      toBe(expected){
        if (result !== expected){
          throw new Error(`${result} √© diferente de ${expected}`)
        } 
      }
  }
}
```
Agora ao executar `node 3.js` temos a seguinte mensagem de erro:
```js
C:\source\github\js-teste-exemplo\3.js:16
                throw new Error(`${actual} √© diferente de ${expected}`)
                ^
Error: 2 √© diferente de 6
    at Object.toBe (C:\source\github\js-teste-exemplo\3.js:16:23)
    at Object.<anonymous> (C:\source\github\js-teste-exemplo\3.js:10:16)
    at Module._compile (node:internal/modules/cjs/loader:1103:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1155:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
```
Certo, voltamos a saber em qual linha `js-teste-exemplo\3.js:10:16` fez o c√≥digo lan√ßar o erro.
Melhor, mas ainda n√£o t√£o claro como o nome da fun√ß√£o. O que fazer ent√£o?

### Passo 4

Criando o arquivo `4.js`.

Vamos escrever uma fun√ß√£o para nos ajudar a solucionar o nosso problema.üòä

```js
const {somar, subtrair} = require('./math')

let result, expected

test('Somar', () => {
  result = somar(4, 2)
  expected = 6
  expect(result).toBe(expected)
})

test('Subtrair', () => {
  result = subtrair(4, 2)
  expected = 2
  expect(result).toBe(expected)
})

// fun√ß√£o criada no passo anterior
function expect(result){
  return {
      toBe(expected){
        if (result !== expected){
          throw new Error(`${result} √© diferente de ${expected}`)
        } 
      }
  }
}

// nossa fun√ß√£o auxiliar
function test(nomeDaFuncao, callback){
  try {
    callback()
    console.log(`‚úì - A fun√ß√£o ${nomeDaFunca} passou no teste!`)
  } catch (error) {
    console.log(`X - A fun√ß√£o ${nomeDaFunca} N√ÉO passou no teste!`)
    console.log(error)
  }
}
```

Ao executar `node 4.js` temos agora uma mensagem de erro **personalizada**, sabendo claramente
qual √© o nome da fun√ß√£o que n√£o passou no nosso teste!  üòå

```js
PS C:\source\github\js-teste-exemplo> node 4
X - A fun√ß√£o somar n√£o passou no teste!
Error: 2 √© diferente de 6!
    at Object.toBe (C:\source\github\js-teste-exemplo\4.js:37:23)
    at C:\source\github\js-teste-exemplo\4.js:10:20
    at test (C:\source\github\js-teste-exemplo\4.js:24:9)
    at Object.<anonymous> (C:\source\github\js-teste-exemplo\4.js:6:1)
    at Module._compile (node:internal/modules/cjs/loader:1103:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1155:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47
‚úì - A fun√ß√£o subtrair passou no teste!
```
#### Passo 5

Agora vamos extrair essas duas fun√ß√µes e colocar em um novo arquivo chamado `minhaLibDeTeste.js` 
(voc√™ pode batiz√°-lo com qualquer nome que achar conveniente)

Esse novo arquivo vai ficar assim:
```js
// minhaLibDeTeste
function expect(result){
  return {
      toBe(expected){
        if (result !== expected){
          throw new Error(`${result} √© diferente de ${expected}`)
        } 
      }
  }
}

/* Ao inv√©s de s√≥ extrair a fun√ß√£o test, vamos deix√°-la mais interessante?
Que tal cores para ficar visualmente melhor?
  - Verde para testes que passaram
  - Vermelho para testes que falharam
*/

function test(nomeDaFuncao, callback){
  try {
    callback()
    console.log('\u001b[1;32m' + `‚úì - A fun√ß√£o ${nomeDaFunca} passou no teste!` + '\u001b[0m')
  } catch (error) {
    console.log('\u001b[1;31m' + `X - A fun√ß√£o ${nomeDaFunca} N√ÉO passou no teste!` '\u001b[0m')
    console.log(error)
  }
}

module.exports = { expect, test }
```

#### Passo 6

Agora que voc√™ criou a sua lib de testes `minhaLibDeTeste`, vamos utiliz√°-la para fazer nosso teste,
criando o arquivo 5.js

```js
// 5.js
const {somar, subtrair} = require('./math')
const {expect, test} = require('./minhaLibDeTeste')

let result, expected

test('somar', () => {
  result = somar(4, 2)
  expected = 6

  expected(result).toBe(expected)
})

test('subtrair', () => {
  result = subtrair(4, 2)
  expected = 2

  expected(result).toBe(expected)
})

```

Execute `node 5.js`e veja a m√°gica acontecer. Voil√†! üòú


#### Passo 6

Por fim, vamos utilizar um √≥timo framework de teste, que √© muito utilizado no mercado,
chamado [Jest](https://github.com/facebook/jest). ([Saiba mais sobre Jest aqui](http://kcd.im/egghead-jest)).

**instala√ß√£o** : abra o seu terminal e cole `npm install --save-dev jest`
Ap√≥s o t√©rmino da instala√ß√£o, abre o seu `package.json` e, para facilitar, adicione as seguintes linhas:

```js
"scripts": {
    "test": "jest",
    "test:all": "node 1.js && node 2.js && node 3.js && node 4.js && jest"
  },
"jest": {
    "testMatch": ["**/6.js"]
  }
```

Agora crie o arquivo `6.js` e digite o c√≥digo abaixo. Repara que voc√™ n√£o mais precisa importar
a fun√ß√£o `test` e nem `expect`. Isso porque o Jest tem exatamente essas fun√ß√µes em seu framework
e mais! funcionam exatamente como n√≥s a criamos! ü§Ø

Isso mesmo, voc√™ criou fun√ß√µes que existem no framework de teste de JavaScript mais popular! üëè

```js
// 6.js
const {somar, subtrair} = require('./math')

test('somar', () => {
  const result = somar(4, 2)
  const expected = 6
  expect(result).toBe(expected)
})

test('subtrair', () => {
  const result = subtrair(4, 2)
  const expected = 2
  expect(result).toBe(expected)
})
```

Para executar o teste basta executar `npm test` que o node vai testar o arquivo `6.js`.

[Screenshot do output - colorido](https://res.cloudinary.com/igorvenancio-com/image/upload/v1654173958/samples/testeColorido_dndv66.jpg)

```js
C:\source\github\js-teste-exemplo> npm test

> js-teste-examplo@1.0.0 test
> jest

 FAIL  ./6.js
  √ó somar (4 ms)
  ‚àö subtrair

  ‚óè somar

    expect(received).toBe(expected) // Object.is equality

    Expected: 6
    Received: 2

       7 |     expected = 6
       8 |
    >  9 |     expect(result).toBe(expected)
         |                    ^
      10 | })
      11 |
      12 | test('subtrair', () => {

      at Object.toBe (6.js:9:20)

Test Suites: 1 failed, 1 total                                                                                                           
Tests:       1 failed, 1 passed, 2 total                                                                                                 
Snapshots:   0 total
Time:        0.437 s, estimated 1 s
Ran all test suites.
```

Por texto n√£o √© poss√≠vel ver exatamente as cores do output, mas segue uma imagem
que tirei do meu console agora:

[Screenshot usando Jest](https://res.cloudinary.com/igorvenancio-com/image/upload/v1654173959/samples/testeComJest_lt5a3d.jpg)


### Conclus√£o

Ent√£o, o que √© um teste em Javacript? Basicamente √© algum c√≥digo onde n√≥s definimos algum estado,
executamos alguma a√ß√£o e fazemos uma asser√ß√£o no novo estado para verificar se o c√≥digo respondeu
como n√≥s quer√≠amos que respondesse.

N√£o nos aprofundamos sobre outras fun√ß√µes de teste, mas espero que esse post tenha
conseguido te dar uma ideia do fundamento que est√° por tr√°s de todos os testes.

Espero que esse post tenha sido √∫til para voc√™! üëç

Um abra√ßo,

Igor Venancio


Obs.: **Compartilhe** com algu√©m que se interessaria por esse assunto.


